<!DOCTYPE html>
<html lang="fr">

	<head>
		<meta charset="UTF-8"> <!-- Définit l'encodage du document -->
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<!-- Indique à Internet Explorer d'utiliser la dernière version de rendu -->
		<meta name="viewport" content="width=device-width, initial-scale=1.0"> <!-- Définit la vue mobile responsive -->
		<title>Ma page web en 3D</title> <!-- Titre de la page affiché dans l'onglet du navigateur -->
		<meta name="language" content="fr"> <!-- Langue principale du contenu de la page -->
		<meta name="keywords" content="mot-clé1, mot-clé2, mot-clé3"> <!-- Mots-clés pour les moteurs de recherche -->
		<meta name="author" content="Nom de l'auteur"> <!-- Auteur de la page -->
		<meta name="description" content="Description de votre page">
		<!-- Description de la page pour les moteurs de recherche -->
		<!-- Balises Open Graph pour les réseaux sociaux -->
		<meta property="og:title" content="Ma page web en 3D">
		<meta property="og:description" content="Description de votre page">
		<meta property="og:image" content="URL_de_votre_image.jpg">
		<meta property="og:url" content="URL_de_votre_page">
		<meta property="og:type" content="website">
		<!-- Balises Twitter pour l'aperçu Twitter -->
		<meta name="twitter:card" content="summary">
		<meta name="twitter:title" content="Ma page web en 3D">
		<meta name="twitter:description" content="Description de votre page">
		<meta name="twitter:image" content="URL_de_votre_image.jpg">
		<!-- Balise pour contrôler l'indexation par les moteurs de recherche -->
		<meta name="robots" content="index,follow">

		<style>
			body {
				margin: 0;
			}
		</style>
	</head>

	<body>
		<!-- Inclure la bibliothèque Three.js -->
		<script src="three.min.js"></script>

		<!-- Script pour contrôler la caméra et la scène -->
		<script src="OrbitControls.js"></script>

		<script>
			// Attendre que la page soit complètement chargée avant d'exécuter le code
			window.onload = function init() {
				// Créer une nouvelle scène 3D
				const scene = new THREE.Scene();

				// Créer une caméra perspective
				const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

				// Positionner la caméra en (0, 0, 10)
				camera.position.x = 0;
				camera.position.y = 0;
				camera.position.z = 10;

				// Créer un rendu WebGL
				const renderer = new THREE.WebGLRenderer({ antialias: true });
				renderer.setSize(window.innerWidth, window.innerHeight);

				// Configuration du rendu
				renderer.outputEncoding = THREE.sRGBEncoding;
				renderer.shadowMap.enabled = true;
				renderer.setPixelRatio(window.devicePixelRatio);

				// Ajouter le rendu à la page
				document.body.appendChild(renderer.domElement);

				// Contrôles pour déplacer la caméra
				const controls = new THREE.OrbitControls(camera, renderer.domElement);

				// Créer une lumière ambiante
				const ambient = new THREE.AmbientLight(0xffffff, 0.1);
				scene.add(ambient);

				// Créer une lampe projecteur (spotlight)
				const spotLight = new THREE.SpotLight(0xffffff, 1);
				spotLight.position.set(0, 0, 20);
				spotLight.angle = Math.PI / 4;
				spotLight.penumbra = 0.1;
				spotLight.decay = 2;
				spotLight.distance = 200;

				// Activer les ombres pour la lampe projecteur
				spotLight.castShadow = true;
				spotLight.shadow.mapSize.width = 512;
				spotLight.shadow.mapSize.height = 512;
				spotLight.shadow.camera.near = 1;
				spotLight.shadow.camera.far = 200;
				spotLight.shadow.focus = 1;

				// Créer un assistant visuel pour la lampe projecteur
				const slHelper = new THREE.SpotLightHelper(spotLight);

				// Ajouter la lampe projecteur, son assistant, et sa cible à la scène
				scene.add(spotLight, slHelper, spotLight.target);

				// Créer un cube rouge
				const bg1 = new THREE.BoxGeometry(1, 1, 1);
				const bm1 = new THREE.MeshPhongMaterial({ color: 0xff0000 });
				const boxMesh1 = new THREE.Mesh(bg1, bm1);
				boxMesh1.castShadow = true;
				boxMesh1.position.x = -2;
				boxMesh1.position.y = 0;
				boxMesh1.position.z = 2;
				scene.add(boxMesh1);

				// Créer un cube vert
				const bg2 = new THREE.BoxGeometry(1, 1, 1);
				const bm2 = new THREE.MeshPhongMaterial({ color: 0x00ff00 });
				const boxMesh2 = new THREE.Mesh(bg2, bm2);
				boxMesh2.castShadow = true;
				boxMesh2.position.x = 0;
				boxMesh2.position.y = 0;
				boxMesh2.position.z = 2;
				scene.add(boxMesh2);

				// Créer un cube bleu
				const bg3 = new THREE.BoxGeometry(1, 1, 1);
				const bm3 = new THREE.MeshPhongMaterial({ color: 0x0000ff });
				const boxMesh3 = new THREE.Mesh(bg3, bm3);
				boxMesh3.castShadow = true;
				boxMesh3.position.x = 2;
				boxMesh3.position.y = 0;
				boxMesh3.position.z = 2;
				scene.add(boxMesh3);

				// Créer le sol
				const groundGeometry = new THREE.BoxGeometry(9, 9, 0.5);
				const groundMaterial = new THREE.MeshPhongMaterial({ color: 0xfafafa });
				const groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
				groundMesh.receiveShadow = true;
				groundMesh.position.z = -2;
				scene.add(groundMesh);

				// Vitesse de déplacement du cube vert
				const deplacementCube = 0.1;

				// Fonction pour animer la scène
				function animate() {
					requestAnimationFrame(animate);

					// Déplacer le cube vert en fonction des touches fléchées
					if (keys.ArrowUp) {
						boxMesh2.position.y += deplacementCube;
					}
					if (keys.ArrowDown) {
						boxMesh2.position.y -= deplacementCube;
					}
					if (keys.ArrowLeft) {
						boxMesh2.position.x -= deplacementCube;
					}
					if (keys.ArrowRight) {
						boxMesh2.position.x += deplacementCube;
					}
					// Déplacement du cube vert avec les touches Q, S, D, Z
					if (keys.KeyW) {
						boxMesh2.position.z -= deplacementCube;
					}
					if (keys.KeyS) {
						boxMesh2.position.z += deplacementCube;
					}
					if (keys.KeyA) {
						boxMesh2.position.x -= deplacementCube;
					}
					if (keys.KeyD) {
						boxMesh2.position.x += deplacementCube;
					}

					// Mettre à jour la projection de la caméra et les contrôles
					camera.aspect = window.innerWidth / window.innerHeight;
					camera.updateProjectionMatrix();
					controls.update();

					// Rendu de la scène
					renderer.render(scene, camera);
				}

				// Objet pour stocker l'état des touches
				const keys = {};

				// Fonction pour gérer les événements liés aux touches
				function handleKeydown(event) {
					keys[event.key] = true;
				}

				function handleKeyup(event) {
					keys[event.key] = false;
				}

				// Ajouter des écouteurs d'événements pour les touches
				window.addEventListener('keydown', handleKeydown);
				window.addEventListener('keyup', handleKeyup);

				// Appeler la fonction d'animation
				animate();

				// Gérer le redimensionnement de la fenêtre
				window.addEventListener('resize', onWindowResize);

				function onWindowResize() {
					camera.aspect = window.innerWidth / window.innerHeight;
					camera.updateProjectionMatrix();
					renderer.setSize(window.innerWidth, window.innerHeight);
				}
			}
		</script>
		<style>
			.links {
				position: absolute;
				bottom: 5px;
				right: 5px;
			}

			.link {
				width: 50px;
				height: 25px;
				background-color: white;
			}
		</style>
		<div class="links">
			<div class="link"><a href="exo1.html">Exo 1</a></div>
			<div class="link"><a href="exo2.html">Exo 2</a></div>
			<div class="link"><a href="exo3.html">Exo 3</a></div>
		</div>
	</body>

</html>
